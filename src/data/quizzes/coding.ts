import type { QuizQuestion } from './types'

export const codingQuestions: QuizQuestion[] = [
  {
    id: 'cq-1',
    question: 'Which pattern should you use for "Find the longest substring with at most K distinct characters"?',
    options: ['Two Pointers', 'Sliding Window', 'Binary Search', 'Dynamic Programming'],
    correctIndex: 1,
    explanation: 'Sliding Window is the pattern for contiguous subarray/substring problems. Expand right, shrink left when the window becomes invalid. O(n) time.',
    priority: 'must-know',
  },
  {
    id: 'cq-2',
    question: 'What is the time complexity of a hash table lookup (average case)?',
    options: ['O(n)', 'O(log n)', 'O(1)', 'O(n log n)'],
    correctIndex: 2,
    explanation: 'Hash tables provide O(1) average-case lookup by mapping keys to indices via a hash function. This is why "use a hash map" is often the key optimization.',
    priority: 'must-know',
  },
  {
    id: 'cq-3',
    question: 'When should you use BFS instead of DFS?',
    options: ['When you need to find the longest path', 'When you need the shortest path in an unweighted graph', 'When you want to save memory', 'When the graph is dense'],
    correctIndex: 1,
    explanation: 'BFS explores level by level, guaranteeing the shortest path in unweighted graphs. DFS is better for exploring all paths or when you need to go deep first.',
    priority: 'must-know',
  },
  {
    id: 'cq-4',
    question: 'What are the two key properties that indicate a Dynamic Programming approach?',
    options: ['Sorted data + unique elements', 'Optimal substructure + overlapping subproblems', 'Binary tree + balanced', 'Contiguous + fixed size'],
    correctIndex: 1,
    explanation: 'DP applies when the problem has optimal substructure (optimal solution contains optimal solutions to subproblems) AND overlapping subproblems (same subproblems solved multiple times).',
    priority: 'must-know',
  },
  {
    id: 'cq-5',
    question: 'For "Kth Largest Element", which data structure provides the most efficient solution?',
    options: ['Array with sorting', 'Min-heap of size K', 'Linked list', 'Stack'],
    correctIndex: 1,
    explanation: 'A min-heap of size K maintains the K largest elements. The top of the heap is the Kth largest. O(n log k) time, better than O(n log n) sorting.',
    priority: 'must-know',
  },
  {
    id: 'cq-6',
    question: 'What is the Monotonic Stack pattern used for?',
    options: ['Sorting elements', 'Finding the next greater/smaller element efficiently', 'Tree traversal', 'Graph shortest path'],
    correctIndex: 1,
    explanation: 'Monotonic Stack solves "next greater/smaller element" problems in O(n) amortized time. Elements in the stack are "waiting" for their answer.',
    priority: 'must-know',
  },
  {
    id: 'cq-7',
    question: 'What is the time complexity of binary search?',
    options: ['O(n)', 'O(n²)', 'O(log n)', 'O(1)'],
    correctIndex: 2,
    explanation: 'Binary search halves the search space each step, giving O(log n) time. It requires the data to be sorted or the search space to be monotonic.',
    priority: 'must-know',
  },
  {
    id: 'cq-8',
    question: 'In Union-Find, what does "path compression" optimize?',
    options: ['Memory usage', 'The find operation by flattening the tree structure', 'The number of unions needed', 'Graph connectivity'],
    correctIndex: 1,
    explanation: 'Path compression makes every node point directly to the root during find(), flattening the tree. Combined with union by rank, operations become nearly O(1) amortized.',
    priority: 'good-to-know',
  },
  {
    id: 'cq-9',
    question: 'Which sorting algorithm is used internally by JavaScript\'s Array.sort()?',
    options: ['Bubble Sort', 'Quick Sort', 'Timsort (hybrid of Merge Sort and Insertion Sort)', 'Heap Sort'],
    correctIndex: 2,
    explanation: 'Most modern JavaScript engines use Timsort, which combines Merge Sort and Insertion Sort. It performs well on real-world data with O(n log n) worst case.',
    priority: 'good-to-know',
  },
  {
    id: 'cq-10',
    question: 'What is the key insight for solving Two Sum in O(n) time?',
    options: ['Sort the array first', 'Use a hash map to check for the complement', 'Use nested loops', 'Use binary search'],
    correctIndex: 1,
    explanation: 'Store each number in a hash map as you iterate. For each number, check if (target - number) exists in the map. This gives O(n) time with O(n) space.',
    priority: 'must-know',
  },
  {
    id: 'cq-11',
    question: 'What is the space complexity of a recursive DFS on a tree with n nodes?',
    options: ['O(1)', 'O(log n) for balanced trees', 'O(n) in the worst case', 'O(n²)'],
    correctIndex: 2,
    explanation: 'Recursive DFS uses O(h) stack space where h is the height. In the worst case (skewed tree), h = n so space is O(n). For balanced trees, it is O(log n).',
    priority: 'good-to-know',
  },
  {
    id: 'cq-12',
    question: 'Which technique converts a nested loop (O(n²)) solution into O(n)?',
    options: ['Using a hash map for O(1) lookups', 'Adding more loops', 'Recursion', 'Increasing the input size'],
    correctIndex: 0,
    explanation: 'Replacing the inner loop with a hash map lookup is the most common optimization pattern. It trades O(n) space for an O(n) time improvement.',
    priority: 'must-know',
  },
]
