import type { QuizQuestion } from './types'

export const technicalLeadershipQuestions: QuizQuestion[] = [
  {
    id: 'tl-1',
    question: 'What is the recommended capacity allocation model for balancing tech debt with product features?',
    options: ['100% features, fix debt in spare time', '50/50 split', '20% tech debt, 10% developer experience, 70% product features', '30% tech debt, 70% features'],
    correctIndex: 2,
    explanation: 'The 20-10-70 model makes tech debt work visible and sustainable: 20% debt reduction, 10% developer experience, 70% product features. This prevents debt from being hidden in slack time.',
    priority: 'must-know',
  },
  {
    id: 'tl-2',
    question: 'What is an ADR (Architecture Decision Record) and when should you write one?',
    options: ['A code review document, written after implementation', 'A document capturing architectural decisions with context, written BEFORE implementing', 'A meeting notes template', 'A deployment checklist'],
    correctIndex: 1,
    explanation: 'ADRs capture architectural decisions with their context, alternatives considered, and consequences. Write them BEFORE implementing to ensure informed, reviewable decisions.',
    priority: 'must-know',
  },
  {
    id: 'tl-3',
    question: 'In the Make vs Buy framework, what is the strongest signal to "Build"?',
    options: ['Speed to market is critical', 'Available commodity solutions exist', 'The capability is core competitive differentiation', 'The team is small'],
    correctIndex: 2,
    explanation: 'If the capability is your competitive moat, build it. You cannot differentiate on something everyone buys from the same vendor. Everything else leans toward buy.',
    priority: 'must-know',
  },
  {
    id: 'tl-4',
    question: 'What should happen when >50% of an error budget is burned in a month?',
    options: ['Nothing, continue normal work', 'Freeze new features and focus on reliability', 'Fire the on-call engineer', 'Double the team size'],
    correctIndex: 1,
    explanation: 'Error budgets make reliability objective: when >50% is burned, freeze features and focus on reliability. This converts subjective arguments into measurable triggers.',
    priority: 'must-know',
  },
  {
    id: 'tl-5',
    question: 'What is the biggest risk of not translating tech debt into business language?',
    options: ['Engineers will not understand it', 'It will get defunded because executives see no business value', 'The code will get worse', 'Nothing, tech debt is an engineering concern'],
    correctIndex: 1,
    explanation: 'Tech debt presented as "messy code" gets ignored. Present it as "costing X eng-hours/quarter with Y revenue risk" to get executive buy-in. It must be a business decision.',
    priority: 'must-know',
  },
  {
    id: 'tl-6',
    question: 'In Trunk-Based Development, what separates deployment from release?',
    options: ['Nothing, they are the same thing', 'Feature flags â€” code is deployed but activated only when ready', 'Manual QA between stages', 'Separate repositories'],
    correctIndex: 1,
    explanation: 'Feature flags allow incomplete features to be deployed to trunk without being released to users. This enables continuous deployment while controlling feature visibility.',
    priority: 'must-know',
  },
  {
    id: 'tl-7',
    question: 'What is the recommended maximum on-call page frequency per engineer per week?',
    options: ['Unlimited, it is part of the job', '<5 actionable pages', '<20 pages', '<50 pages'],
    correctIndex: 1,
    explanation: 'If an engineer receives >5 pages/week on non-actionable alerts, treat it as a P1. Alert fatigue is the #1 cause of attrition in infra-heavy teams.',
    priority: 'good-to-know',
  },
  {
    id: 'tl-8',
    question: 'What is the primary difference between PMLC and SDLC?',
    options: ['They are the same thing', 'PMLC has a defined end; SDLC continues indefinitely into maintenance', 'SDLC ends first', 'PMLC is only for waterfall projects'],
    correctIndex: 1,
    explanation: 'PMLC (Project Management Life Cycle) has a defined closure. SDLC (Software Development Life Cycle) continues into maintenance long after the project closes.',
    priority: 'good-to-know',
  },
  {
    id: 'tl-9',
    question: 'In code review culture, what is the #1 developer productivity killer?',
    options: ['Too many tests', 'PRs sitting unreviewed for more than 24 hours', 'Too many meetings', 'Slow CI/CD'],
    correctIndex: 1,
    explanation: 'Unreviewed PRs create context-switching costs for the author and merge conflicts for other PRs. Review latency is the most impactful developer productivity metric most teams never measure.',
    priority: 'must-know',
  },
  {
    id: 'tl-10',
    question: 'What is the "Strangler Fig" pattern?',
    options: ['A testing pattern', 'Replacing legacy systems incrementally while keeping them running', 'A deployment strategy', 'A team structure'],
    correctIndex: 1,
    explanation: 'The Strangler Fig pattern replaces legacy systems piece by piece while the old system remains running. New functionality goes to the new system; old functionality is migrated over time.',
    priority: 'good-to-know',
  },
  {
    id: 'tl-11',
    question: 'What should a blameless post-mortem focus on?',
    options: ['Who caused the incident', 'Contributing factors and systemic fixes', 'Individual performance reviews', 'Punishing the responsible team'],
    correctIndex: 1,
    explanation: 'Blameless post-mortems focus on "what allowed this to happen?" not "who caused this?" They identify contributing factors and systemic fixes that prevent recurrence.',
    priority: 'must-know',
  },
]
