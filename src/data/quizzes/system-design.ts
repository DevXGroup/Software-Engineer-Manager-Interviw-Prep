import type { QuizQuestion } from './types'

export const systemDesignQuestions: QuizQuestion[] = [
  {
    id: 'sd-1',
    question: 'For a URL shortener with a 100:1 read-to-write ratio, which caching strategy is most appropriate?',
    options: ['Write-through cache', 'Write-behind cache', 'Cache-aside (lazy loading)', 'No caching needed'],
    correctIndex: 2,
    explanation: 'Cache-aside is ideal for read-heavy systems. On miss, read from DB and populate cache. With 100:1 read:write, cache hit rates of 80%+ make redirects sub-millisecond.',
    priority: 'must-know',
  },
  {
    id: 'sd-2',
    question: 'In the CAP theorem, what does a distributed system have to choose between when a network partition occurs?',
    options: ['Consistency and Availability', 'Cost and Performance', 'Capacity and Availability', 'Concurrency and Atomicity'],
    correctIndex: 0,
    explanation: 'CAP theorem: during a network partition, you must choose between Consistency (all nodes see the same data) and Availability (every request gets a response). You cannot have both.',
    priority: 'must-know',
  },
  {
    id: 'sd-3',
    question: 'How does Twitter handle the "celebrity problem" in feed generation?',
    options: ['Fan-out on write for everyone', 'Fan-out on read for everyone', 'Hybrid: fan-out on write for normal users, fan-out on read for celebrities', 'No fan-out, just SQL queries'],
    correctIndex: 2,
    explanation: 'Twitter uses a hybrid approach. Normal users\' tweets are pushed to followers\' timelines (fan-out on write). Celebrities with millions of followers use fan-out on read to avoid millions of cache writes per tweet.',
    priority: 'must-know',
  },
  {
    id: 'sd-4',
    question: 'What is the primary advantage of consistent hashing over simple modulo hashing?',
    options: ['It is faster', 'It minimizes key redistribution when nodes are added/removed', 'It uses less memory', 'It guarantees ordering'],
    correctIndex: 1,
    explanation: 'Consistent hashing minimizes key redistribution when nodes change. Only keys between the new/removed node and its neighbor are affected, rather than almost all keys being reassigned.',
    priority: 'must-know',
  },
  {
    id: 'sd-5',
    question: 'Which database type is best suited for a social media timeline service?',
    options: ['Graph database (Neo4j)', 'Document store (MongoDB)', 'Wide-column store (Cassandra)', 'Relational (PostgreSQL)'],
    correctIndex: 2,
    explanation: 'Wide-column stores like Cassandra excel at time-series data with high write throughput and multi-region support, making them ideal for timeline storage at social media scale.',
    priority: 'good-to-know',
  },
  {
    id: 'sd-6',
    question: 'In a rate limiter, what is the "boundary attack" problem with Fixed Window Counters?',
    options: ['The counter overflows', 'Users can send 2x the limit by timing requests around window boundaries', 'Windows cannot be smaller than 1 minute', 'It requires too much memory'],
    correctIndex: 1,
    explanation: 'Fixed Window has a boundary attack: 100 requests at 0:59 + 100 requests at 1:01 = 200 requests in 2 seconds, double the intended limit. Sliding Window Counter solves this.',
    priority: 'must-know',
  },
  {
    id: 'sd-7',
    question: 'For a notification system, why should click tracking be asynchronous?',
    options: ['To reduce development cost', 'Synchronous analytics kills redirect/delivery performance', 'Async is easier to implement', 'There is no difference'],
    correctIndex: 1,
    explanation: 'Synchronous analytics adds write contention and latency to the critical path. Use Kafka to emit click events asynchronously, then process them in a separate stream pipeline.',
    priority: 'must-know',
  },
  {
    id: 'sd-8',
    question: 'What is the recommended pagination strategy for a high-throughput feed like Twitter?',
    options: ['OFFSET-based pagination', 'Cursor-based pagination using tweet_id', 'Page number pagination', 'No pagination, load everything'],
    correctIndex: 1,
    explanation: 'Cursor-based pagination (using tweet_id as cursor) provides consistent results during rapid updates. OFFSET pagination can miss or duplicate items when new data is inserted.',
    priority: 'good-to-know',
  },
  {
    id: 'sd-9',
    question: 'When should you use Kafka over a simple message queue like SQS?',
    options: ['For any async task', 'When you need event replay, multiple consumers, and ordering within partitions', 'When you need exactly-once delivery', 'Only for small-scale systems'],
    correctIndex: 1,
    explanation: 'Kafka excels at event streaming with persistent logs, multiple consumers reading the same events, replay capability, and ordered processing within partitions. SQS is better for simple task queues.',
    priority: 'must-know',
  },
  {
    id: 'sd-10',
    question: 'What is the primary purpose of database sharding?',
    options: ['To backup data', 'To horizontally partition rows across multiple DB instances', 'To encrypt data', 'To compress storage'],
    correctIndex: 1,
    explanation: 'Sharding splits rows across multiple DB instances by a shard key, enabling horizontal scaling when a single database can no longer handle the load.',
    priority: 'must-know',
  },
  {
    id: 'sd-11',
    question: 'In a URL shortener, what is the advantage of Base62 encoding over MD5 hashing for short codes?',
    options: ['Base62 is more secure', 'Base62 avoids collision risk when paired with a sequence generator', 'Base62 is faster', 'There is no advantage'],
    correctIndex: 1,
    explanation: 'Base62 encoding a unique ID from a Snowflake-style generator ensures uniqueness without collisions. MD5 hashing has collision risk and requires collision detection logic.',
    priority: 'good-to-know',
  },
  {
    id: 'sd-12',
    question: 'What does the Circuit Breaker pattern prevent in distributed systems?',
    options: ['Data loss', 'Cascade failures when a downstream service is unhealthy', 'SQL injection', 'Network partitions'],
    correctIndex: 1,
    explanation: 'The Circuit Breaker pattern fails fast when a downstream service is unhealthy, preventing cascade failures from propagating through the system. It includes automatic recovery.',
    priority: 'must-know',
  },
]
